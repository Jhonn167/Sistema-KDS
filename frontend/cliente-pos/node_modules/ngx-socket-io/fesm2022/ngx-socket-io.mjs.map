{"version":3,"file":"ngx-socket-io.mjs","sources":["../../src/socket-io.service.ts","../../src/socket-io.module.ts","../../ngx-socket-io.ts"],"sourcesContent":["import { ApplicationRef } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { share } from 'rxjs/operators';\n\nimport * as ioModule from 'socket.io-client';\nimport type { io, Socket } from 'socket.io-client';\nimport type {\n  ReservedOrUserListener,\n  ReservedOrUserEventNames,\n  DefaultEventsMap,\n  EventsMap,\n  EventNames,\n  EventParams,\n} from '@socket.io/component-emitter';\n\nimport { SocketIoConfig } from './config/socket-io.config';\n\nexport type IoSocket<\n  ListenEvents extends EventsMap = DefaultEventsMap,\n  EmitEvents extends EventsMap = ListenEvents,\n> = Socket<ListenEvents, EmitEvents>;\n// socket.io-client internal types for emitWithAck\nexport type First<T extends any[]> = T extends [infer F, ...infer L] ? F : any;\nexport type Last<T extends any[]> = T extends [...infer H, infer L] ? L : any;\nexport type AllButLast<T extends any[]> = T extends [...infer H, infer L]\n  ? H\n  : any[];\nexport type FirstArg<T> = T extends (arg: infer Param) => infer Result\n  ? Param\n  : any;\n// This is not exported in the original, but let's export as helpers for those declaring disconnect handlers\nexport type DisconnectDescription =\n  | Error\n  | {\n      description: string;\n      context?: unknown;\n    };\n\n// Not exported but needed to properly map ReservedEvents to their signatures\ninterface SocketReservedEvents {\n  connect: () => void;\n  connect_error: (err: Error) => void;\n  disconnect: (\n    reason: Socket.DisconnectReason,\n    description?: DisconnectDescription\n  ) => void;\n}\n\ntype IgnoredWrapperEvents = 'receiveBuffer' | 'sendBuffer';\n\ntype WrappedSocketIface<Wrapper> = {\n  [K in Exclude<keyof IoSocket, IgnoredWrapperEvents>]: IoSocket[K] extends (\n    ...args: any[]\n  ) => IoSocket\n    ? (...args: Parameters<IoSocket[K]>) => Wrapper // chainable methods on().off().emit()...\n    : IoSocket[K] extends IoSocket\n      ? Wrapper // ie: volatile is a getter\n      : IoSocket[K];\n};\n\nexport class WrappedSocket<\n  ListenEvents extends EventsMap = DefaultEventsMap,\n  EmitEvents extends EventsMap = ListenEvents,\n> implements WrappedSocketIface<WrappedSocket>\n{\n  private readonly subscribersCounter: Partial<\n    Record<ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>, number>\n  > = {};\n  private readonly eventObservables$: Partial<\n    Record<\n      ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n      Observable<any>\n    >\n  > = {};\n  private readonly namespaces: Record<string, WrappedSocket> = {};\n  readonly ioSocket: IoSocket<ListenEvents, EmitEvents>;\n  private readonly emptyConfig: SocketIoConfig = {\n    url: '',\n    options: {},\n  };\n\n  constructor(\n    private config: SocketIoConfig,\n    private appRef: ApplicationRef\n  ) {\n    if (config === undefined) {\n      config = this.emptyConfig;\n    }\n    const url: string = config.url;\n    const options: any = config.options;\n    const ioFunc = (\n      (ioModule as any).default ? (ioModule as any).default : ioModule\n    ) as typeof io;\n    this.ioSocket = ioFunc(url, options);\n  }\n\n  get auth(): Socket['auth'] {\n    return this.ioSocket.auth;\n  }\n\n  set auth(value: Socket['auth']) {\n    this.ioSocket.auth = value;\n  }\n\n  /** readonly access to io manager */\n  get io(): Socket['io'] {\n    return this.ioSocket.io;\n  }\n\n  /** alias to connect */\n  get open(): WrappedSocket['connect'] {\n    return this.connect;\n  }\n\n  /** alias to disconnect */\n  get close(): WrappedSocket['disconnect'] {\n    return this.disconnect;\n  }\n\n  /**\n   * Gets a WrappedSocket for the given namespace.\n   *\n   * @note if an existing socket exists for the given namespace, it will be reused.\n   *\n   * @param namespace the namespace to create a new socket based on the current config.\n   *        If empty or `/`, then the current instance is returned.\n   * @returns a socket that is bound to the given namespace. If namespace is empty or `/`,\n   *          then `this` is returned, otherwise another instance is returned, creating\n   *          it if it's the first use of such namespace.\n   */\n  of(namespace: string): WrappedSocket {\n    if (!namespace || namespace === '/') {\n      return this;\n    }\n    const existing = this.namespaces[namespace];\n    if (existing) {\n      return existing;\n    }\n    const { url, ...rest } = this.config;\n    const config = {\n      url:\n        !url.endsWith('/') && !namespace.startsWith('/')\n          ? `${url}/${namespace}`\n          : `${url}${namespace}`,\n      ...rest,\n    };\n    const created = new WrappedSocket(config, this.appRef);\n    this.namespaces[namespace] = created;\n    return created;\n  }\n\n  on<Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>>(\n    eventName: Ev,\n    callback: ReservedOrUserListener<SocketReservedEvents, ListenEvents, Ev>\n  ): this {\n    this.ioSocket.on<Ev>(eventName, callback);\n    return this;\n  }\n\n  once<Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>>(\n    eventName: Ev,\n    callback: ReservedOrUserListener<SocketReservedEvents, ListenEvents, Ev>\n  ): this {\n    this.ioSocket.once<Ev>(eventName, callback);\n    return this;\n  }\n\n  connect(): this {\n    this.ioSocket.connect();\n    return this;\n  }\n\n  disconnect(): this {\n    this.ioSocket.disconnect();\n    return this;\n  }\n\n  emit<\n    Ep extends EventParams<EmitEvents, Ev>,\n    Ev extends EventNames<EmitEvents> = EventNames<EmitEvents>,\n  >(eventName: Ev, ...args: Ep): this {\n    this.ioSocket.emit(eventName, ...args);\n    return this;\n  }\n\n  send(..._args: any[]): this {\n    this.ioSocket.send.apply(this.ioSocket, arguments);\n    return this;\n  }\n\n  emitWithAck<\n    Ep extends EventParams<EmitEvents, Ev>,\n    Ev extends EventNames<EmitEvents> = EventNames<EmitEvents>,\n  >(eventName: Ev, ...args: AllButLast<Ep>): Promise<FirstArg<Last<Ep>>> {\n    return this.ioSocket.emitWithAck(eventName, ...args);\n  }\n\n  removeListener<\n    Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n  >(\n    eventName?: Ev,\n    callback?: ReservedOrUserListener<SocketReservedEvents, ListenEvents, Ev>\n  ): this {\n    this.ioSocket.removeListener<Ev>(eventName, callback);\n    return this;\n  }\n\n  removeAllListeners<\n    Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n  >(eventName?: Ev): this {\n    this.ioSocket.removeAllListeners<Ev>(eventName);\n    return this;\n  }\n\n  fromEvent<\n    Ep extends First<EventParams<ListenEvents, Ev>>,\n    Ev extends ReservedOrUserEventNames<\n      SocketReservedEvents,\n      ListenEvents\n    > = ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n  >(eventName: Ev): Observable<Ep> {\n    if (!this.subscribersCounter[eventName]) {\n      this.subscribersCounter[eventName] = 0;\n    }\n    this.subscribersCounter[eventName]!++;\n\n    if (!this.eventObservables$[eventName]) {\n      this.eventObservables$[eventName] = new Observable<Ep>(observer => {\n        const listener: any = (data: Ep) => {\n          observer.next(data);\n          this.appRef.tick();\n        };\n        this.ioSocket.on(eventName, listener);\n        return () => {\n          this.subscribersCounter[eventName]!--;\n          if (this.subscribersCounter[eventName] === 0) {\n            this.ioSocket.removeListener(eventName, listener);\n            delete this.eventObservables$[eventName];\n          }\n        };\n      }).pipe(share());\n    }\n    return this.eventObservables$[eventName];\n  }\n\n  fromOneTimeEvent<\n    Ep extends ReservedOrUserListener<SocketReservedEvents, ListenEvents, Ev>,\n    Ev extends ReservedOrUserEventNames<\n      SocketReservedEvents,\n      ListenEvents\n    > = ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n  >(eventName: Ev): Promise<Ep> {\n    return new Promise<Ep>(resolve => this.once(eventName, resolve as Ep));\n  }\n\n  listeners<\n    Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n  >(\n    eventName: Ev\n  ): ReservedOrUserListener<SocketReservedEvents, ListenEvents, Ev>[] {\n    return this.ioSocket.listeners(eventName);\n  }\n\n  hasListeners<\n    Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>,\n  >(eventName: Ev): boolean {\n    return this.ioSocket.hasListeners(eventName);\n  }\n\n  listenersAny(): ((...args: any[]) => void)[] {\n    return this.ioSocket.listenersAny();\n  }\n\n  listenersAnyOutgoing(): ((...args: any[]) => void)[] {\n    return this.ioSocket.listenersAnyOutgoing();\n  }\n\n  off<Ev extends ReservedOrUserEventNames<SocketReservedEvents, ListenEvents>>(\n    eventName?: Ev,\n    listener?: ReservedOrUserListener<SocketReservedEvents, ListenEvents, Ev>\n  ): this {\n    this.ioSocket.off<Ev>(eventName, listener);\n    return this;\n  }\n\n  offAny(callback?: (event: string, ...args: any[]) => void): this {\n    this.ioSocket.offAny(callback);\n    return this;\n  }\n\n  offAnyOutgoing(callback?: (event: string, ...args: any[]) => void): this {\n    this.ioSocket.offAnyOutgoing(callback);\n    return this;\n  }\n\n  onAny(callback: (event: string, ...args: any[]) => void): this {\n    this.ioSocket.onAny(callback);\n    return this;\n  }\n\n  onAnyOutgoing(callback: (event: string, ...args: any[]) => void): this {\n    this.ioSocket.onAnyOutgoing(callback);\n    return this;\n  }\n\n  prependAny(callback: (event: string, ...args: any[]) => void): this {\n    this.ioSocket.prependAny(callback);\n    return this;\n  }\n\n  prependAnyOutgoing(\n    callback: (event: string | symbol, ...args: any[]) => void\n  ): this {\n    this.ioSocket.prependAnyOutgoing(callback);\n    return this;\n  }\n\n  timeout(value: number): this {\n    this.ioSocket.timeout(value);\n    return this;\n  }\n\n  get volatile(): this {\n    // this getter has a side-effect of turning the socket instance true,\n    // but it returns the actual instance, so we need to get the value to force the side effect\n    const _ = this.ioSocket.volatile;\n    return this;\n  }\n\n  get active(): Socket['active'] {\n    return this.ioSocket.active;\n  }\n\n  get connected(): Socket['connected'] {\n    return this.ioSocket.connected;\n  }\n\n  get disconnected(): Socket['disconnected'] {\n    return this.ioSocket.disconnected;\n  }\n\n  get recovered(): Socket['recovered'] {\n    return this.ioSocket.recovered;\n  }\n\n  get id(): Socket['id'] {\n    return this.ioSocket.id;\n  }\n\n  compress(value: boolean): this {\n    this.ioSocket.compress(value);\n    return this;\n  }\n}\n","import {\n  NgModule,\n  ModuleWithProviders,\n  InjectionToken,\n  makeEnvironmentProviders,\n  EnvironmentProviders,\n  ApplicationRef,\n} from '@angular/core';\nimport { SocketIoConfig } from './config/socket-io.config';\nimport { WrappedSocket } from './socket-io.service';\n\n/** Socket factory */\nexport function SocketFactory(config: SocketIoConfig, appRef: ApplicationRef) {\n  return new WrappedSocket(config, appRef);\n}\n\nexport const SOCKET_CONFIG_TOKEN = new InjectionToken<SocketIoConfig>(\n  '__SOCKET_IO_CONFIG__'\n);\n\n@NgModule({})\nexport class SocketIoModule {\n  static forRoot(config: SocketIoConfig): ModuleWithProviders<SocketIoModule> {\n    return {\n      ngModule: SocketIoModule,\n      providers: [\n        { provide: SOCKET_CONFIG_TOKEN, useValue: config },\n        {\n          provide: WrappedSocket,\n          useFactory: SocketFactory,\n          deps: [SOCKET_CONFIG_TOKEN, ApplicationRef],\n        },\n      ],\n    };\n  }\n}\n\nexport const provideSocketIo = (\n  config: SocketIoConfig\n): EnvironmentProviders => {\n  return makeEnvironmentProviders([\n    { provide: SOCKET_CONFIG_TOKEN, useValue: config },\n    {\n      provide: WrappedSocket,\n      useFactory: SocketFactory,\n      deps: [SOCKET_CONFIG_TOKEN, ApplicationRef],\n    },\n  ]);\n};\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}